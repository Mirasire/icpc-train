#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <string>
#include <queue>
#include <vector>
using namespace std;

const int Vm = 5e3+100,Em = 5e4+100,INF = 0x3f3f3f;

struct EDGE {
	int to,next,flow,cap,cost,idx;
	void init(int to,int next,int cap,int cost,int cnt) {
		this->flow = 0;
		this->to = to;
		this->next = next;
		this->cap = cap;
		this->cost = cost;
		this->idx = cnt;
	}
};

struct MCFC {
	int head[Vm],cur[Vm],dist[Vm];
	int minCost,cnt,t;
	bool vis[Vm];
	EDGE edge[Em];
	MCFC() {cnt = -1;}

	void AddEdge(int a,int b,int cap,int cost) {
		edge[++cnt].init(b,head[a],cap,cost,cnt); head[a] = cnt;
		edge[++cnt].init(a,head[b],0,-cost,cnt); head[b] = cnt;
	}

	bool spfa() {
		//init
		minCost = 0;
		int now,i;
		fill(dist,dist+Vm,INF);
		memcpy(cur,head,sizeof(head)); //maybe for dfs?

		queue<int> list;
		list.push(s);
		vis[s] = 1;
		dist[s] = 0;
		while(!list.empty()) {
			now = list.front();
			list.pop();
			vis[now] = 0;
			for(i = head[now]; i; i=edge[i].next) {
				EDGE& e = edge[i];
				if(e.cap > e.flow && dist[e.to] > dist[now] + e.cost) {
					if(!vis[e.to]) vis[e.to]=1,list.push(e.to);
					dist[e.to] = dist[now] + e.cost;
				}
			}
		}
		return dist[t]!=INF;
	}

	int dfs(int u,int f) {
		if(u == t || f == 0) return f;
		vis[u] = 1;
		int ff = 0,rf = 0;
		for(int& i=cur[i]; i; i=edge[i].next) {
			EDGE& e = edge[i];
			if(!vis[e.to] && e.cap > e.flow && (dist[e.to] == dist[u] + e.cost) && (ff = dfs(e.to,min(f,e.cap-e.flow))) > 0) {
				minCost += ff*e.cost;
				e.flow += ff;
				edge[e.cnt^1] -= ff;
				f -= ff;
				rf += ff;
			}
		}
		return rf;
	}

	int mcfc(int s,int t) {
		int maxFlow = 0;
		this->s = s; this->t = t;
		while(spfa()) maxFlow += dfs(s,INF);
		return maxFlow;
	}
};

int main() {
	return 0;
}
